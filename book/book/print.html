<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>system-performance</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="linux_60-Second_analysis.html"><strong aria-hidden="true">1.</strong> Linux 60 Second Analysis</a></li><li class="chapter-item expanded "><a href="bpftrace.html"><strong aria-hidden="true">2.</strong> Bpftrace one-line commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bpftrace/cpu.html"><strong aria-hidden="true">2.1.</strong> CPU</a></li><li class="chapter-item expanded "><a href="bpftrace/memory.html"><strong aria-hidden="true">2.2.</strong> Memory</a></li><li class="chapter-item expanded "><a href="bpftrace/fs.html"><strong aria-hidden="true">2.3.</strong> File Systems</a></li><li class="chapter-item expanded "><a href="bpftrace/disk.html"><strong aria-hidden="true">2.4.</strong> Disks</a></li><li class="chapter-item expanded "><a href="bpftrace/networking.html"><strong aria-hidden="true">2.5.</strong> Networking</a></li></ol></li><li class="chapter-item expanded "><a href="observability_tools/introdution.html"><strong aria-hidden="true">3.</strong> observability_tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="observability_tools/memory.html"><strong aria-hidden="true">3.1.</strong> Memory</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_1/introdution.html"><strong aria-hidden="true">4.</strong> Technology Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1/bpf.html"><strong aria-hidden="true">4.1.</strong> BPF</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">system-performance</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="linux-60-second-analysis"><a class="header" href="#linux-60-second-analysis">Linux 60-Second Analysis</a></h2>
<ol>
<li>
<p>uptime</p>
<p>this is a quick way to view the load average, which indicate the number of tasks(process) wanting to run. On Linux system, these numberts include process wanting to run on the CPUs, <strong>as well as processes blocked in uninterruptible  I/O</strong> (usually disk I/O).</p>
</li>
<li>
<p>dmesg | tail</p>
</li>
<li>
<p>vmstat 1</p>
<pre><code class="language-bash">--procs-- -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
   r    b         swpd         free         buff        cache   si   so    bi    bo   in   cs  us  sy  id  wa  st
   2    0            0      4390360        93524      1843900    0    0   171    25  103  252   2   1  97   0   0
   0    0            0      4384880        93524      1843900    0    0     0     0  544  975   1   0  99   0   0
   0    0            0      4386152        93524      1843964    0    0     0    16  932 2595   1   0  99   0   0

</code></pre>
<p><strong>r:</strong> the number of processes running on CPU and waiting for a turn. this provide a better signal than load averages for determining CPU saturation, as it does not include I/O. <strong>To interpret: an &quot;r&quot; value greater than CPU count indicates saturation</strong></p>
<p><strong>si and so:</strong> Swap-ins and swap-outs. if these are non-zero, you're out of memory.</p>
<p><strong>us, sy, id, wa, and st:</strong> These are breakdowns of CPU time, on average, across all CPUs. they are user time, system time(kernel), idle, wait I/O, and stolen time(the guest's own isolated driver domain).</p>
</li>
<li>
<p>mpstat -P ALL 1</p>
<p>This command prints per-CPU time broken down into states.</p>
<p><strong>high %iowait time</strong>, which can be explored with disk I/O tools, and <strong>high %sys time</strong>, which an be explored with syscall and kernel tracing, as well as CPU profiling.</p>
</li>
<li>
<p>pidstat 1</p>
<p>shows CPU usage per process.</p>
</li>
<li>
<p>iostat -xz 1</p>
<p>This tool shows storage device I/O metrics. The output columns for each disk device have line-wrapped here.</p>
<p><strong>await</strong>: The average time for the I/O in milliseconds. This is time that the application suffers, as it include both time queued and time being serviced. Larger-than-expected average times can be an indicator of device saturation or device problem.</p>
</li>
<li>
<p>free -m</p>
</li>
<li>
<p>sar -n DEV 1 </p>
<p>The sar tool has many modes for different groups of metrics. Here I'm using it to look at network device metrics. Check interface throughput rxKB/s and txKB/s to see if any limit may have been reached.</p>
</li>
<li>
<p>sar -n TCP,ETCP 1</p>
<p>TCP metrics and TCP error.</p>
<p><strong>active/s:</strong> 			Number of locally initiated TCP connections per second(e.g., via connect())</p>
<p><strong>passive/s:</strong> 		 Number of remotely initiated TCP connections per second (e.g, via accept())	</p>
<p><strong>retrans/s:</strong> 		  Number of TCP retransmits per second.</p>
</li>
<li>
<p>top</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bpftrace-one-line-commands"><a class="header" href="#bpftrace-one-line-commands">Bpftrace one-line commands</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cpus"><a class="header" href="#cpus">CPUs</a></h2>
<ul>
<li>Trace new processes with arguments:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:syscalls:sys_enter_execve { join(args-&gt;argv); }'
</code></pre>
<ul>
<li>Count syscalls by process:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[pid, comm] = count(); }'
</code></pre>
<ul>
<li>Count syscalls by syscall probe name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:syscalls:sys_enter_* { @[probe] = count(); }'
</code></pre>
<ul>
<li>Sample running process names at 99 Hertz:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'profile:hz:99 { @[comm] = count(); }'
</code></pre>
<ul>
<li>Sample user and kernel stacks at 49 Hertz, system wide, with the process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'profile:hz:49 { @[kstack, ustack, comm] = count(); }'
</code></pre>
<ul>
<li>Sample user-level stacks at 49 Hertz, for PID 189:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'profile:hz:49 /pid == 189/ { @[ustack] = count(); }'
</code></pre>
<ul>
<li>Sample user-level stacks 5 frames deep at 49 Hertz, for PID 189:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'profile:hz:49 /pid == 189/ { @[ustack(5)] = count(); }'804
</code></pre>
<ul>
<li>Sample user-level stacks at 49 Hertz, for processes named “mysqld”:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'profile:hz:49 /comm == &quot;mysqld&quot;/ { @[ustack] = count(); }'
</code></pre>
<ul>
<li>Count kernel CPU scheduler tracepoints:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepont:sched:* { @[probe] = count(); }'
</code></pre>
<ul>
<li>Count off-CPU kernel stacks for context switch events:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepont:sched:sched_switch { @[kstack] = count(); }'
</code></pre>
<ul>
<li>Count kernel function calls beginning with “vfs_”:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kprobe:vfs_* { @[func] = count(); }'
</code></pre>
<ul>
<li>Trace new threads via pthread_create():</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'u:/lib/x86_64-linux-gnu/libpthread-2.27.so:pthread_create {printf(&quot;%s by %s (%d)\n&quot;, probe, comm, pid); }'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="memory"><a class="header" href="#memory">Memory</a></h2>
<ul>
<li>Sum libc malloc() request bytes by user stack and process (high overhead):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'u:/lib/x86_64-linux-gnu/libc.so.6:malloc {@[ustack, comm] = sum(arg0); }'
</code></pre>
<ul>
<li>Sum libc malloc() request bytes by user stack for PID 181 (high overhead):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'u:/lib/x86_64-linux-gnu/libc.so.6:malloc /pid == 181/ {@[ustack] = sum(arg0); }'
</code></pre>
<ul>
<li>Show libc malloc() request bytes by user stack for PID 181 as a power-of-2 histogram (high overhead):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'u:/lib/x86_64-linux-gnu/libc.so.6:malloc /pid == 181/ {@[ustack] = hist(arg0); }'
</code></pre>
<ul>
<li>Sum kernel kmem cache allocation bytes by kernel stack trace:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:kmem:kmem_cache_alloc { @bytes[kstack] = sum(args-&gt;bytes_alloc); }'
</code></pre>
<ul>
<li>Count process heap expansion (brk(2)) by code path:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:syscalls:sys_enter_brk { @[ustack, comm] = count(); }'
</code></pre>
<ul>
<li>Count page faults by process:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'software:page-fault:1 { @[comm, pid] = count(); }'bpftrace One-Liners
</code></pre>
<ul>
<li>Count user page faults by user-level stack trace:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:exceptions:page_fault_user { @[ustack, comm] = count(); }'
</code></pre>
<ul>
<li>Count vmscan operations by tracepoint:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:vmscan:* { @[probe]++; }'
</code></pre>
<ul>
<li>Count swapins by process:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kprobe:swap_readpage { @[comm, pid] = count(); }'
</code></pre>
<ul>
<li>Count page migrations:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:migrate:mm_migrate_pages { @ = count(); }'
</code></pre>
<ul>
<li>Trace compaction events:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:compaction:mm_compaction_begin { time(); }'
</code></pre>
<ul>
<li>List USDT probes in libc:</li>
</ul>
<pre><code class="language-bash">bpftrace -l 'usdt:/lib/x86_64-linux-gnu/libc.so.6:*'
</code></pre>
<ul>
<li>List kernel kmem tracepoints:</li>
</ul>
<pre><code class="language-bash">bpftrace -l 't:kmem:*'
</code></pre>
<ul>
<li>List all memory subsystem (mm) tracepoints:</li>
</ul>
<pre><code class="language-bash">bpftrace -l 't:*:mm_*'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="file-systems"><a class="header" href="#file-systems">File Systems</a></h2>
<ul>
<li>Trace files opened via openat(2) with process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:syscalls:sys_enter_openat { printf(&quot;%s %s\n&quot;, comm,str(args-&gt;filename)); }'
</code></pre>
<ul>
<li>Count read syscalls by syscall type:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:syscalls:sys_enter_*read* { @[probe] = count(); }'
</code></pre>
<ul>
<li>Count write syscalls by syscall type:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:syscalls:sys_enter_*write* { @[probe] = count(); }'
</code></pre>
<ul>
<li>Show the distribution of read() syscall request sizes:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:syscalls:sys_enter_read { @ = hist(args-&gt;count); }'
</code></pre>
<ul>
<li>Show the distribution of read() syscall read bytes (and errors):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:syscalls:sys_exit_read { @ = hist(args-&gt;ret); }'
</code></pre>
<ul>
<li>Count read() syscall errors by error code:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:syscalls:sys_exit_read /args-&gt;ret &lt; 0/ { @[- args-&gt;ret] = count(); }'
</code></pre>
<ul>
<li>Count VFS calls:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kprobe:vfs_* { @[probe] = count(); }'
</code></pre>
<ul>
<li>Count VFS calls for PID 181:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kprobe:vfs_* /pid == 181/ { @[probe] = count(); }'
</code></pre>
<ul>
<li>Count ext4 tracepoints:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:ext4:* { @[probe] = count(); }'
</code></pre>
<ul>
<li>Count xfs tracepoints:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:xfs:* { @[probe] = count(); }'
</code></pre>
<ul>
<li>Count ext4 file reads by process name and user-level stack:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kprobe:ext4_file_read_iter { @[ustack, comm] = count(); }'
</code></pre>
<ul>
<li>Trace ZFS spa_sync() times:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kprobe:spa_sync { time(&quot;%H:%M:%S ZFS spa_sync()\n&quot;); }'
</code></pre>
<ul>
<li>Count dcache references by process name and PID:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kprobe:lookup_fast { @[comm, pid] = count(); }'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disks"><a class="header" href="#disks">Disks</a></h2>
<ul>
<li>Count block I/O tracepoints events:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'tracepoint:block:* { @[probe] = count(); }'
</code></pre>
<ul>
<li>Summarize block I/O size as a histogram:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:block:block_rq_issue { @bytes = hist(args-&gt;bytes); }'
</code></pre>
<ul>
<li>Count block I/O request user stack traces:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:block:block_rq_issue { @[ustack] = count(); }'
</code></pre>
<ul>
<li>Count block I/O type flags:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:block:block_rq_issue { @[args-&gt;rwbs] = count(); }'bpftrace One-Liners
</code></pre>
<ul>
<li>Trace block I/O errors with device and I/O type:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:block:block_rq_complete /args-&gt;error/ {printf(&quot;dev %d type %s error %d\n&quot;, args-&gt;dev, args-&gt;rwbs, args-&gt;error); }'
</code></pre>
<ul>
<li>Count SCSI opcodes:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:scsi:scsi_dispatch_cmd_start { @opcode[args-&gt;opcode] = count(); }'
</code></pre>
<ul>
<li>Count SCSI result codes:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:scsi:scsi_dispatch_cmd_done { @result[args-&gt;result] = count(); }'
</code></pre>
<ul>
<li>Count SCSI driver function calls:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kprobe:scsi* { @[func] = count(); }'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<ul>
<li>Count socket accept(2)s by PID and process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:syscalls:sys_enter_accept* { @[pid, comm] = count(); }'
</code></pre>
<ul>
<li>Count socket connect(2)s by PID and process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:syscalls:sys_enter_connect { @[pid, comm] = count(); }'
</code></pre>
<ul>
<li>Count socket connect(2)s by user stack trace:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:syscalls:sys_enter_connect { @[ustack, comm] = count(); }'
</code></pre>
<ul>
<li>Count socket send/receives by direction, on-CPU PID, and process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:sock_sendmsg,k:sock_recvmsg { @[func, pid, comm] = count(); }'
</code></pre>
<ul>
<li>Count socket send/receive bytes by on-CPU PID and process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kr:sock_sendmsg,kr:sock_recvmsg /(int32)retval &gt; 0/ { @[pid, comm] = sum((int32)retval); }'
</code></pre>
<ul>
<li>Count TCP connects by on-CPU PID and process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:tcp_v*_connect { @[pid, comm] = count(); }'
</code></pre>
<ul>
<li>Count TCP accepts by on-CPU PID and process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:inet_csk_accept { @[pid, comm] = count(); }'
</code></pre>
<ul>
<li>Count TCP send/receives by on-CPU PID and process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:tcp_sendmsg,k:tcp_recvmsg { @[func, pid, comm] = count(); }'
</code></pre>
<ul>
<li>TCP send bytes as a histogram:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:tcp_sendmsg { @send_bytes = hist(arg2); }'
</code></pre>
<ul>
<li>TCP receive bytes as a histogram:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kr:tcp_recvmsg /retval &gt;= 0/ { @recv_bytes = hist(retval); }'
</code></pre>
<ul>
<li>Count TCP retransmits by type and remote host (assumes IPv4):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:tcp:tcp_retransmit_* { @[probe, ntop(2, args-&gt;saddr)] = count(); }'
</code></pre>
<ul>
<li>Count all TCP functions (adds high overhead to TCP):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:tcp_* { @[func] = count(); }'
</code></pre>
<ul>
<li>Count UDP send/receives by on-CPU PID and process name:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:udp*_sendmsg,k:udp*_recvmsg { @[func, pid, comm] = count(); }'
</code></pre>
<ul>
<li>UDP send bytes as a histogram:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:udp_sendmsg { @send_bytes = hist(arg2); }'
</code></pre>
<ul>
<li>UDP receive bytes as a histogram:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'kr:udp_recvmsg /retval &gt;= 0/ { @recv_bytes = hist(retval); }'
</code></pre>
<ul>
<li>Count transmit kernel stack traces:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:net:net_dev_xmit { @[kstack] = count(); }'
</code></pre>
<ul>
<li>Show receive CPU histogram for each device:</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:net:netif_receive_skb { @[str(args-&gt;name)] = lhist(cpu, 0, 128, 1); }'
</code></pre>
<ul>
<li>Count ieee80211 layer functions (adds high overhead to packets):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:ieee80211_* { @[func] = count()'
</code></pre>
<ul>
<li>Count all ixgbevf device driver functions (adds high overhead to ixgbevf):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 'k:ixgbevf_* { @[func] = count(); }'
</code></pre>
<ul>
<li>Count all iwl device driver tracepoints (adds high overhead to iwl):</li>
</ul>
<pre><code class="language-bash">bpftrace -e 't:iwlwifi:*,t:iwlwifi_io:* { @[probe] = count(); }'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="memory-observability-tools"><a class="header" href="#memory-observability-tools">Memory observability tools</a></h2>
<ol>
<li>
<h3 id="vmstat"><a class="header" href="#vmstat">vmstat</a></h3>
<pre><code class="language-bash">vmstat -Sm 1 # to megabytes
vmstat -a 1  # print a breakdown of inactive and active from page cache
vmstat -w 1  # wide output
</code></pre>
</li>
<li>
<h3 id="psi-linux-pressure-stall-information-added-in-linux-420"><a class="header" href="#psi-linux-pressure-stall-information-added-in-linux-420">PSI (linux pressure stall information) added in linux 4.20</a></h3>
<pre><code class="language-bash">cat /proc/pressure/memory
#some avg10=2.84 avg60=1.23 avg300=0.32 total=1468344
#full avg10=1.85 avg60=0.66 avg300=0.16 total=702578
</code></pre>
<p>PSI statistics are also tracked per cgroup2</p>
</li>
<li>
<h3 id="swapon"><a class="header" href="#swapon">swapon</a></h3>
<pre><code class="language-bash">swapon
#NAME           TYPE       SIZE USED PRIO
#/dev/nvme0n1p7 partition 15.6G   0B   -2
</code></pre>
</li>
<li>
<h3 id="sar-system-activity-reporter"><a class="header" href="#sar-system-activity-reporter">sar (system activity reporter)</a></h3>
<ul>
<li>
<p><strong>-B:</strong> paging statistics</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Statistics</th><th style="text-align: center">Description</th><th style="text-align: center">Unit</th></tr></thead><tbody>
<tr><td style="text-align: center">pgpgin/s</td><td style="text-align: center">Page-ins</td><td style="text-align: center">Kbytes/s</td></tr>
<tr><td style="text-align: center">pgpgout/s</td><td style="text-align: center">Page-outs</td><td style="text-align: center">Kbytes/s</td></tr>
<tr><td style="text-align: center">faults/s</td><td style="text-align: center">Both major and minor faults</td><td style="text-align: center">Count/s</td></tr>
<tr><td style="text-align: center">majflt/s</td><td style="text-align: center">Major faults</td><td style="text-align: center">Count/s</td></tr>
<tr><td style="text-align: center">pgfree/s</td><td style="text-align: center">Pages added to free list</td><td style="text-align: center">Count/s</td></tr>
<tr><td style="text-align: center">pgscank/s</td><td style="text-align: center">Pages scanned by background page-out daemon(kswapd)</td><td style="text-align: center">Count/s</td></tr>
<tr><td style="text-align: center"><strong>pgscand/s</strong></td><td style="text-align: center">Direct page scans</td><td style="text-align: center">Count/s</td></tr>
<tr><td style="text-align: center">pgsteal/s</td><td style="text-align: center">Page and swap cache reclaims</td><td style="text-align: center">Count/s</td></tr>
<tr><td style="text-align: center"><strong>%vmeff</strong></td><td style="text-align: center">Ratio of page steal/page scan,which shows page reclaim efficiency<br />The %vmeff metric is a useful measure of page reclaims efficiency. High means pages are successfully stolen from the inactive list(healthy); low means the system is struggling. the man page describes near 100% as high, and less than 30% as low.</td><td style="text-align: center">Percent</td></tr>
</tbody></table>
</div></li>
<li>
<p><strong>-H:</strong> Huge pages statistics</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Statistics</th><th style="text-align: center">Description</th><th style="text-align: center">Unit</th></tr></thead><tbody>
<tr><td style="text-align: center">hbhugefree</td><td style="text-align: center">Free huge pages memory (large page size)</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">hbhugeused</td><td style="text-align: center">Used huge pages memory</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">%hugeused</td><td style="text-align: center">Huge page usage</td><td style="text-align: center">Percent</td></tr>
</tbody></table>
</div></li>
<li>
<p><strong>-r:</strong> Memory utilization</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Statistics</th><th style="text-align: center">Description</th><th style="text-align: center">Unit</th></tr></thead><tbody>
<tr><td style="text-align: center">kbmemfree</td><td style="text-align: center">Free memory (completely unused)</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbavail</td><td style="text-align: center">Available memory,including pages that can be readily freed from the page cache</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbmemused</td><td style="text-align: center">Used memory (excluding the kernel)</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">%memused</td><td style="text-align: center">Memory usage</td><td style="text-align: center">Percent</td></tr>
<tr><td style="text-align: center">kbbuffers</td><td style="text-align: center">Buffer cache size</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbcached</td><td style="text-align: center">Page cache size</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbcommit</td><td style="text-align: center">Main memory committed: an estimate of the amount needed to serve the current workload</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">%commit</td><td style="text-align: center">Main memory committed for current workload, estimate</td><td style="text-align: center">Percent</td></tr>
<tr><td style="text-align: center">kbactive</td><td style="text-align: center">Active list memory size</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbinact</td><td style="text-align: center">Inactive list memory size</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbdirtyw</td><td style="text-align: center">Modified memory to be written to disk</td><td style="text-align: center">Kbytes</td></tr>
</tbody></table>
</div></li>
<li>
<p><strong>-r ALL</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Statistics</th><th style="text-align: center">Description</th><th style="text-align: center">Unit</th></tr></thead><tbody>
<tr><td style="text-align: center">kbanonpg</td><td style="text-align: center">Process anonymous memory</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbslab</td><td style="text-align: center">Kernel slab cache size</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbkstack</td><td style="text-align: center">Kernel stack space size</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbpgtbl</td><td style="text-align: center">Lowest-level page table size</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbvmuused</td><td style="text-align: center">Used virtual address space</td><td style="text-align: center">Kbytes</td></tr>
</tbody></table>
</div></li>
<li>
<p><strong>-S:</strong> Swap space statistics</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Statistics</th><th style="text-align: center">Description</th><th style="text-align: center">Unit</th></tr></thead><tbody>
<tr><td style="text-align: center">kbswapfree</td><td style="text-align: center">Free swap space</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">kbswapused</td><td style="text-align: center">Used swap space</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">%swpused</td><td style="text-align: center">Used swap space</td><td style="text-align: center">Percent</td></tr>
<tr><td style="text-align: center">kbswpcad</td><td style="text-align: center">Cached swap space: this resides in both main memory and the swap device and so can be paged out without disk  I/O</td><td style="text-align: center">Kbytes</td></tr>
<tr><td style="text-align: center">%swpcad</td><td style="text-align: center">Ratio of cached swap versus used swap</td><td style="text-align: center">Percent</td></tr>
</tbody></table>
</div></li>
<li>
<p><strong>-W:</strong> Swapping statistics</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Statistics</th><th style="text-align: center">Description</th><th style="text-align: center">Unit</th></tr></thead><tbody>
<tr><td style="text-align: center">pswpin/s</td><td style="text-align: center">Page-ins(Linux &quot;swap-ins&quot;)</td><td style="text-align: center">Pages/s</td></tr>
<tr><td style="text-align: center">pswpout/s</td><td style="text-align: center">Page-outs(Linux &quot;swap-outs&quot;)</td><td style="text-align: center">Pages/s</td></tr>
</tbody></table>
</div></li>
</ul>
</li>
<li>
<h3 id="slabtop-prints-kernel-slab-cache-usage-from-the-slab-allocator"><a class="header" href="#slabtop-prints-kernel-slab-cache-usage-from-the-slab-allocator">slabtop: prints kernel slab cache usage from the slab allocator</a></h3>
<pre><code class="language-bash">slabtop -sc # sort by cache size
</code></pre>
</li>
<li>
<h3 id="numastat"><a class="header" href="#numastat">numastat</a></h3>
</li>
<li>
<h3 id="ps"><a class="header" href="#ps">ps</a></h3>
<pre><code class="language-bash">ps -oe pid,pmem,vsz,rss,comm # using the SVR4-style -o option
</code></pre>
</li>
<li>
<h3 id="top"><a class="header" href="#top">top</a></h3>
<pre><code class="language-bash">top -o %MEM # sort by memory usage
</code></pre>
</li>
<li>
<h3 id="pmap"><a class="header" href="#pmap">pmap</a></h3>
<pre><code class="language-bash">pmap -x  5187
pmap -X  5187  # more details
pmap -XX 5187
</code></pre>
</li>
<li>
<h3 id="perf"><a class="header" href="#perf">perf</a></h3>
<ul>
<li>
<p>One-Liners</p>
<pre><code class="language-bash"># Sample page faults (RSS growth) with stack traces system wide
perf record -e page-faults -a -g
# Record all page faults with stack traces for PID 1843, for 60 seconds
perf record -e page-faults -c 1 -p 1822 -g -- sleep 60
# Record heap growth via brk(2)
perf record -e syscalls:sys_enter_brk -a -g
# Record page migrations on NUMA systems
perf record -e migrate:mm_migrate_pages -a
# Count all kmem events, printing a report every second
perf stat -e 'kmem:*' -a -I 1000
# Count all vmscan events, printing a report every second
perf stat -e 'vmscan:*' -a -I 1000
# Count memory compaction events, printing a report every second
perf stat -e 'compaction:*' -a -I 1000
# Trace kswapd wakeup events with stack traces
perf record -e vmscan:mm_vmscan_wakeup_kswapd  -ag
# Profile memory access for the given command
perf mem record command
# Summarize a memory profile
perf mem report
# Print all events
perf script --header
</code></pre>
<p>How to generate flame graph?</p>
<pre><code class="language-bash"># perf record -e page-faults -a -g -- sleep 60
# perf script --header &gt; out.stacks
$ git clone https://github.com/brendangregg/FlameGraph; cd FlameGraph
$ ./stackcollapse-perf.pl &lt; ../out.stacks | ./flamegraph.pl --hash \
--bgcolor=green --count=pages --title=&quot;Page Fault Flame Graph&quot; &gt; out.svg
</code></pre>
</li>
</ul>
</li>
<li>
<h3 id="drsnoop"><a class="header" href="#drsnoop">drsnoop</a></h3>
<p>is a BCC tool for tracing the direct reclaim approach to freeing memory, showing the process affected and the latency: the time taken for the reclaim.</p>
<p>It can be used to quantify the application performance impact of a memory-constrained system.</p>
<pre><code class="language-bash">drsnoop -T
</code></pre>
</li>
<li>
<h3 id="wssworking-set-size"><a class="header" href="#wssworking-set-size">wss(working set size)</a></h3>
<p>this tools works by resetting the PTE accessed bit for every page in a process, pausing for an interval, and then checking the bits to see which have been set.</p>
<p>WARNINGS: this tool uses <code>/proc/PID/clear_refs</code> and <code>/proc/PID/smaps</code>, which can cause slightly higher application latency (e.g, <strong>10%</strong>) while the kernel walks page structures. For large processes (&gt; 100Gbytes), this duration of higher latency can last over one second, during which this tool is consuming system CPU time.</p>
<p>Keep these overheads in mind. this tool also resets the referenced flag, which might confuse the kernel as to which pages to reclaim, especially if swapping is active.</p>
</li>
<li>
<h3 id="bpftrace"><a class="header" href="#bpftrace">bpftrace</a></h3>
<pre><code class="language-bash"># Show libc malloc() request bytes by user stack for PID 181 as a power-of-2 histogram (high overhead)
bpftrace -e 'uprobe:/lib/x86_64-linux-gnu/libc.so.6:malloc /pid == 181/ { @[ustack] = hist(arg0); }'

# Sum kernel kmem cache allocation bytes by kernel stack trace
bpftrace -e 't:kmem:kmem_cache_alloc {@bytes[kstack] = sum(args-&gt;bytes_alloc);}'

# Count process heap expansion (brk(2)) by code path
bpftrace -e 'tracepoin:syscalls:sys_enter_brk {@[ustack,comm] = count()}'

# Count page faults by process
# Tracing page faults shows when a process grows in memory size.
bpftrace -e 'software:page-fault:1 { @[comm, pid] = count(); }'

# Count user page faults by user-level stack trace
bpftrace -e 't:exceptions:page_fault_user {@[ustack, comm] = count(); }' &gt; out.stacks
git clone https://github.com/brendangregg/FlameGraph; cd FlameGraph ./stackcollapse-bpftrace.pl &lt; ../out.stacks | ./flamegraph.pl --hash \
--bgcolor=green --count=pages --title=&quot;Page Fault Flame Graph&quot; &gt; out.svg

# Count vmscan operations by tracepoint
bpftrace -e 'tracepoint:vmscan:* {@[probe] = count(); }'

# Count swapins by process
bpftrace -e 'kprobe:swap_readpage {@[comm,pid] = count()}'

# Count page migration
bpftrace -e 'tracepoint:migration:mm_migrate_pages {@ = count(); }'

# Trace compaction events
bpftrace -e 't:compaction:mm_compaction_begin { time(); }'

# List USDT probes in libc
bpftrace -e 'usdt:/lib/x86_64-linux-gnu/libc.so.6:*'

# List kernel kmem tracepoints:
bpftrace -l 't:kmem:*'

# List all memory subsystem (mm) tracepoints
bpftracce -l 't:*:mm_*'
bpftrace -l 'tracepoint:kmem:*'

# Listing USDT probes for libc on ubuntu, if the tracepoints and USDT probes are insufficient, consider using dynamic instrumentation with kprobes and uprobes.
bpftrace -l 'usdt:/lib/x86_64-linux-gnu/libc.so.6'
</code></pre>
<p>Since memory events can be very frequent, instrumenting then can consume significant overhead. malloc(3) functions form user space can be called millions of times per second, and with the current uprobes overhead.</p>
<p>tracing them can slow a target two-fold or more, use caution and find ways to reduce this overhead, such as using maps to summarize statistics instead of printing per-event details, and tracing the fewest possible events.</p>
</li>
<li>
<p><strong>pmcarch:</strong> CPU cycle usage including LLC misses</p>
</li>
<li>
<p><strong>tlbstat:</strong> Summarize TLB cycles</p>
</li>
<li>
<p><strong>free:</strong> Cache capacity statistics</p>
</li>
<li>
<p><strong>cachestat:</strong> Page cache statistics</p>
</li>
<li>
<p><strong>oomkill:</strong> shows extra info on OOM kill events</p>
</li>
<li>
<p><strong>memleak:</strong> Shows possible memory leak code paths</p>
</li>
<li>
<p><strong>mmapsnoop:</strong> Trace mmap(2) calls system-wide</p>
</li>
<li>
<p><strong>brkstack:</strong> Show brk() calls with user stack traces</p>
</li>
<li>
<p><strong>shmsnoop:</strong> Traces shared memory calls with details</p>
</li>
<li>
<p><strong>faults:</strong> Show page faults, by user stack trace</p>
</li>
<li>
<p><strong>ffaults:</strong> Show page faults, by filename</p>
</li>
<li>
<p><strong>vmscan:</strong> Measures VM  scanner shrink and reclaim times</p>
</li>
<li>
<p><strong>swapin:</strong> Shows swap-ins by process</p>
</li>
<li>
<p><strong>hfaults:</strong> Shows huge page faults, by process</p>
</li>
<li>
<p><strong>dmesg:</strong> Check for &quot;Out of memory&quot; message from OOM killer.</p>
</li>
<li>
<p><strong>dmidecode:</strong> Show BIOS information for memory bank.</p>
</li>
<li>
<p><strong>tiptop:</strong> A version of top(1) that displays PMC statistics by process.</p>
</li>
<li>
<p><strong>valgrind:</strong> A performance analysis suite.</p>
</li>
<li>
<p><strong>iostat:</strong> if the swap device is a physical disk or slice, device I/O may be observable using iostat(1).</p>
</li>
<li>
<p><code>/proc/zoneinfo</code>: Statistics for memory zone.</p>
</li>
<li>
<p><code>/proc/buddyinfo:</code> Statistics for the kernel buddy allocator for pages.</p>
</li>
<li>
<p><code>/proc/pagetypeinfo:</code> Kernel free memory page statistics; can be used to help debug issues of kernel memory fragmentation.</p>
</li>
<li>
<p><code>/proc/devices/system/node/node*/numastat</code>: statistics for NUMA nodes.</p>
</li>
<li>
<p><strong>SysRq m:</strong> Magic SysRq has an &quot;m&quot; key to dump memory info to the console.</p>
<pre><code class="language-bash">echo m &gt; /proc/sysrq-trigger
dmesg
</code></pre>
<p>This can be useful if the system has locked up, as it may still be possible to request this information using the SysRq key sequence on the console keyboard, if available.%</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>Technology Background</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bpf"><a class="header" href="#bpf">BPF</a></h2>
<ol>
<li>
<p><strong>BPF</strong> was originally developed for the <strong>BSD</strong> operation system.</p>
</li>
<li>
<p><strong>BPF</strong> works in an interesting way: A filter expression is defined by the end user using an instruction set for a BPF virtual machine (sometimes called the BPF byte-code) and then passed to the kernel for execution by a interpreter.</p>
</li>
<li>
<p>(pros) this method allows filtering to occur in the kernel level without costly copies of each packet going to the user-level processes.(improving performance)</p>
</li>
<li>
<p>(pros) it also provide safety, as filters from user space can be verified as being safe before execution.</p>
</li>
<li>
<p>Extended BPF(<strong>eBPF</strong>) added more registers, switched from 32-bit to 64-bit words, created flexible BPF &quot;map&quot; storage, and allowed calls to some restricted kernel functions. it was also designed to be be JITed with a one-to-one mapping instructions and registers, allowing prior native instruction optimization techniques to be reused for BPF. the BPF verifier was also updated to handle these extensions and reject any unsafe code.</p>
</li>
<li>
<p><strong>BPF</strong> programs can execute custom latency calculations and statistical  summaries.</p>
</li>
<li>
<p>what makes <strong>BPF</strong> different is that it is also efficient and production environments withouts needing to add any new kernel components!.</p>
<pre><code class="language-bash">bitehist #shows the size of disk I/O as a histogram
</code></pre>
</li>
<li>
<p><strong>BPF</strong> can be programmed via one of the many front end available. The main ones for tracing are,from lowest-to-highest-level language.</p>
<ul>
<li>LLVM IR</li>
<li>BCC</li>
<li>bpftrace</li>
</ul>
</li>
<li>
<p>bpftool(8) was added in linux 4.15 for viewing and manipulation BPF objects,including programs and maps.</p>
</li>
<li>
<p>the <code>bpftool perf</code> subcommand shows BPF programs attached via <code>perf_event_open()</code>,witch is the norm for BCC and bpftrace programs on linux 4.17 and later.</p>
<pre><code class="language-bash">sudo apt-get install binutils-dev
sudo apt-get install libreadline-dev
cd &lt;linux-source-directory&gt;/tools/bpf/
make
bpftool prog dump xlated id 263 visual &gt; biolatency_done.dot #graphViz
dot -Tpng -Elen=2.5 biolatency_done.dot -o biolatency_done.png
</code></pre>
</li>
<li>
<p>The <code>prog dump jited</code> subcommand shows the machine code for the processor that is executed.</p>
</li>
<li>
<p>The <code>btf dump id &lt;id-number&gt;</code> shows the BTF IDs.</p>
</li>
<li>
<p>A <strong>BPF</strong> program cannot call arbitrary kernel functions. to accomplish certain tasks with this limitation, &quot;helper&quot; functions that BPF can call have been provided.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">BPF Helper Function</th><th>Description</th></tr></thead><tbody>
<tr><td style="text-align: left">bpf_map_lookup_elem(map, key)</td><td><strong>Finds</strong> a key in a map and returns its value(pointer).</td></tr>
<tr><td style="text-align: left">bpf_map_update_elem(map,key,value,flags)</td><td><strong>Update</strong> the value of the entry selected by key.</td></tr>
<tr><td style="text-align: left">bpf_map_delete_elem(map, key)</td><td><strong>Deletes</strong> the entry selected by key from the map.</td></tr>
<tr><td style="text-align: left">bpf_probe_read(dst, size, src)</td><td>Safely reads size bytes from address src n and stores in dst.</td></tr>
<tr><td style="text-align: left">bpf_ktime_get_ns(</td><td>Returns the time since boot,in nanoseconds.</td></tr>
<tr><td style="text-align: left">bpf_trace_printk(fmt, fmt_size, ...)</td><td>A debugging helper that writes to TraceFs trace{_pipe}.</td></tr>
<tr><td style="text-align: left">bpf_get_current_pid_tgid()</td><td>Returns a u64 containing the current TGID (what user space calls the PID) in the upper bits and current PID (what user space calls the kernel thread ID) in the lower bits.</td></tr>
<tr><td style="text-align: left">bpf_perf_event_output(ctx, map, data, size)</td><td>Writes data to the perf_event ring buffers; this is used for per-event output.</td></tr>
<tr><td style="text-align: left">bpf_get_stackid(ctx, map, flags)</td><td>Fetches a user or kernel stack trace and returns an identifier.</td></tr>
<tr><td style="text-align: left">bpf_get_current_task()</td><td>Returns the current task struct. this contains many details about the running process and links to other structs containing system state. Note that these are all considered an unstable API.</td></tr>
<tr><td style="text-align: left">pbf_probe_read_str(dst, size, ptr)</td><td>Copies a NULL terminated string from an unsafe pointer to the destination, limited by size (including the NULL byte).</td></tr>
<tr><td style="text-align: left">bpf_perf_event_read_value(map, flags, buf, size)</td><td>Reads a perf_event counter and stores it in the buf. This is a way to read PMCs during a BPF program.</td></tr>
<tr><td style="text-align: left">bpf_get_current_cgroup_id()</td><td>Returns the current cgroup ID.</td></tr>
<tr><td style="text-align: left">bpf_spin_lock(lock)<br />bpf_spin_unlock(lock)</td><td>Concurrency control for network programs.</td></tr>
<tr><td style="text-align: left">bpf_current_comm(buf, buf_size)</td><td>Copies the task name to the buffer.</td></tr>
</tbody></table>
</div></li>
<li>
<p>The term current in these descriptions refers to the currently running thread. the thread that is currently on-CPU.</p>
</li>
<li>
<p><code>include/uapi/linux/bpf.h</code> file often provides detailed documentation for these helpers.</p>
</li>
<li>
<p><code>bpf_probe_read()</code> is a particularly important helper. Memory access in BPF is restricted to BPF registers and the stack. Arbitrary memory(such as other kernel memory outside of BPF) must be read via <code>pbf_probe_read()</code>, witch performs safety checks and disables page faults to ensure that the reads do not cause faults from probe context (witch could cause kernel problems).</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
